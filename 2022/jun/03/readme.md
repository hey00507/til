# 쿠키, 세션, JWT


###  💻 HTTP 특성

HTTP 는 인터넷 상에서 데이터를 주고 받기 위한 서버/클라이언트 모델을 따르는 프로토콜
클라이언트가 서버에게 요청을 보내면, 서버는 응답을 보냄으로써 데이터를 교환
#### HTTP 의 특징 - 비연결성 및 무상태성
HTTP 는 요청 처리 후 연결을 끊어버리기 때문에, 클라이언트의 상태 정보 및 현재 통신 상태가 남아있지 않다.

이 비연결성의 장점은 서버의 자원 낭비를 줄일 수 있다는 것이다.
만약 다수의 클라이언트와 연결을 유지한다면 자원 낭비가 심해질 것이다.
허나 비연결성은 클라이언트를 식별할 수 없다는 단점 또한 존재한다.
로그인을 하더라도 다음 요청에서 해당 클라이언트를 기억하지 못해서, 무한 로그인을 해야 할 것이다.
심지어 브라우저 새로고침을 누를 때마다 로그인을 해야한다….
이와 같은 문제점을 해결하기 위해 Cookie 와 Session 이라는 기술을 활용한다.

###  🍪 쿠키 (Cookie)
쿠키(Cookie)란 클라이언트가 어떠한 웹사이트를 방문할 경우, 그 사이트가 사용되고 있는 서버를 통해 클라이언트의 브라우저에 설치되는 작은 기록 파일을 일컫는다.
서버는 클라이언트의 로그인 요청에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 응답 헤더의 Set-Cookie에 담는다. (쿠키는 Key-Value 형식의 문자열이다.) 이후 해당 클라이언트는 요청을 보낼 때마다 매번 저장된 쿠키를 요청 헤더의 Cookie에 담아 보낸다. 서버는 쿠키에 담긴 정보를 바탕으로 해당 요청의 클라이언트가 누군지 식별할 수 있다.

#### 쿠키의 단점

보안에 취약하다. (요청 시 쿠키의 값을 그대로 보내어, 유출 및 조작당할 위험이 존재한다.)
용량 제한이 있어, 많은 정보를 담을 수 없다.
웹 브라우저마다 쿠키에 대한 지원 형태가 다르기에, 브라우저 간 공유가 불가능하다.
쿠키의 사이즈가 커질수록 네트워크에 부하가 심해진다.

### 🗃 세션 (Session)

#### 세션 기반 인증

세션은 비밀번호 등 클라이언트의 인증 정보를 쿠키가 아닌 서버 측에 저장하고 관리한다.
서버는 클라이언트의 로그인 요청에 대한 응답을 작성할 때, 인증 정보는 서버에 저장하고, 클라이언트 식별자인 JSESSIONID를 쿠키에 담는다. 이후 클라이언트는 요청을 보낼 때마다 JSESSIONID쿠키를 함께 보낸다. 그리하면 서버는 JSESSIONID의 유효성을 판별해 클라이언트를 식별한다.

#### 세션 기반 인증의 장점

서버가 클라이언트의 웹 브라우저에 의존하지 않아도 된다.
쿠키를 포함한 요청이 외부에 노출되어도 세션 ID 자체는 유의미한 개인 정보를 담지 않는다.
각 사용자마다 고유한 세션 ID가 발급되기 때문에, 요청이 들어올 때마다 회원 정보를 확인(로그인)할 필요 없다.
세션 기반 인증의 단점

해커가 세션 ID를 중간에 탈취하여 클라이언트인 척 위장할 수 있다.
서버에서 세션 저장소를 사용하기 때문에, 요청이 많아지면 서버에 부하가 생긴다.


### 📬 토큰 (Token)

#### 토큰 기반 인증 (JWT)

JWT(JSON Web Token)는 인증에 필요한 정보들을 암호화시킨 토큰이다.
JWT 기반 인증은 쿠키/세션 방식과 유사하게 JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라를 식별한다.

JWT의 구조는 위 사진과 같이 세가지 문자열의 조합이다. 실제 디코딩된 JWT는 Header, Payload, Signature로 이루어져 있다.

#### Header

Header는 alg와 typ을 갖고 있다.
alg는 정보를 암호화할 해싱 알고리즘을, typ는 토큰의 타입을 지정한다.

``` json
{
"alg": "HS256",
"typ": "JWT"
}
```

#### Payload

Payload는 실제로 토큰에 담을 정보를 지니고 있다.
주로 클라이언트 고유 ID, 유효 기간 등이 포함된다.
Key-Value 형식으로 이루어진 한 쌍의 정보를 Claim이라고 한다.
``` json

{
"sub": "1234567890",
"name": "John Doe",
"iat": 1516230922
}
``` 
#### Signature

Signature는 인코딩된 Header와 Payload를 더한 뒤, 비밀키로 해싱하여 생성한다.
Header 및 Payload는 단순 인코딩된 값이기 때문에 해커가 복호화하고 조작할 수 있지만, Signature는 서버 측에서 관리하는 비밀키가 유출되지 않는 이상 복호화할 수 없다.
따라서 Signature는 토큰의 위변조 여부를 확인하는 데 사용된다.

``` json
HMACSHA256(
base64UrlEncode(header) + "." +
base64UrlEncode(payload),
secret_key
)
```

### 토큰 인증 과정

클라이언트 로그인 요청이 들어오면, 서버는 검증 후 클라이언트 고유 ID등의 정보를 Payload에 담는다.
암호화할 비밀키를 사용해 Access Token(JWT)을 발급한다.
클라이언트는 전달받은 토큰을 저장해두고, 서버에 요청할 때마다 토큰을 요청 헤더 Authorization에 포함시켜 함께 전달한다.
서버는 토큰의 Signature 을 비밀키로 복호화한 다음, 위변조 여부 및 유효 기간 등을 확인한다.
유효한 토큰이라면 요청에 응답한다.
토큰의 장점

Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있다.
인증 정보에 대한 별도의 저장소가 필요 없다. (I/O 처리 필요 없음)
JWT는 토큰에 대한 기본 정보와 전달할 정보 및 토큰이 검증됐음을 증명하는 서명 등 필요한 모든 정보를 자체적으로 지니고 있다.
클라이언트의 인증 정보를 저장하는 세션과 다르게, 서버는 무상태(Stateless)가 된다.
확장성이 우수하다.
토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다. (토큰 서버 활용)
토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다.
OAuth의 경우 Facebook, Google 등 소셜 계정을 이용해 다른 웹서비스에서도 로그인 할 수 있다.
모바일 어플리케이션 환경에서도 잘 동작한다.


### 토큰의 단점

쿠키, 세션과 다르게 JWT는 토큰의 길이가 길어, 인증 요청이 많을수록 네트워크 부하가 심해진다.
Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다. (패스워드 등)
토큰을 탈취당하면 대처하기 어렵다. 토큰은 한 번 발급되면 유효기간이 만료될 때까지 계속 사용이 가능하다.
특정 사용자의 접속을 강제로 만료하기 어렵다. (쿠키/세션 기반 인증은 서버 단에서 쉽게 삭제할 수 있지만 토큰은 그게 안 됨)
이러한 단점을 보완하기 위한 토큰 전략들은 몇가지가 있다.
아래에서 살펴보자.

### 짧은 만료 기한 설정

토큰의 만료 기한을 짧게 설정해서 탈취되더라도 빠르게 만료시키는 방법이다.
하지만 이는 토큰이 만료되면 사용자가 다시 로그인해야 한다는 뜻이기에 사용자 입장에서 번거로운 방법이다.

### Sliding Session

서비스를 지속적으로 이용하는 클라이언트에게 자동으로 토큰 만료 기한을 늘려주는 방법이다
만약 글을 작성하다가 토큰이 만료된다면 새로운 토큰을 발급해주는 것이다.
사용자가 로그인을 자주 할 필요가 없다.

### Refresh Token

클라이언트가 로그인할 때 Access Token 및 Refresh Token을 발급해주는 방법이다.
Refresh Token은 Access Token보다 만료 기한이 긴 토큰이다.
클라이언트가 요청을 보냈는데 Access Token이 만료되었을 때, Refresh Token을 이용하여 Access Token의 재발급을 요청한다.
이때 서버는 DB에 저장된 Refresh Token과 비교하여 유효하면 Access Token을 발급한다.
만약 Refresh Token도 만료된 경우라면 사용자에게 로그인을 요구한다.
이 전략을 사용하면 Access Token의 만료 기한을 짧게 설정하여 위의 짧은 만료 기한 설정 전략처럼 탈취되더라도 빠르게 만료될 수 있다. 또한 짧은 만료 기한에도 불구하고 자주 로그인을 할 필요가 없어진다. 서버가 강제로 Refresh Token을 만료시킬 수도 있다.
하지만 이렇게 완벽하게 보이는 Refresh Token 발급 방법도 단점은 있다. Refresh Token 검증을 위해 DB(혹은 별도의 저장소)에 저장해야 하고, 자원이 소요될 뿐더러 추가적인 I/O 작업이 발생한다. (JWT의 장점은 I/O 작업이 필요없는 빠른 인증 처리였다.)

###  🙌 결론

최근에는 서비스 개발에서 JWT를 가장 많이 사용하는 추세라고 한다.
서로의 장단점을 고려해서 내 서비스에 맞는 인증 방법을 사용하자!